(
s.waitForBoot{(
	(
		~tapeBus = Bus.audio(s, 2);
		~inputBus = Bus.audio(s, 2);
		~mixerBus = Bus.audio(s, 2);
		~caesarBus = Bus.audio(s, 2);

		// variables for autogenerated clean pattern
		~cleanBus = Bus.audio(s, 2);
		~cleanPlays = false;
		~segments = 50;
		~length = 10;
		~speed = 1;

		~cleanSpeed = 1;
		~cleanMod = 0;
		// ~cleanLowpass = 20000;
		// ~cleanHipass = 20;

		~seed = 2147483647.rand;
		~t_cleanGate = false;

		// mod targets on/off switches
		~modTapeRate = false;
		~modTapePos = false;
		~modLoopPitch = false;
		~modLoopFeedback = false;
		~modGrainRate = false;
		~modGrainTFreq = false;
		~modGrainOverlap = false;
		~modGrainPos = false;

		// added a little waiting time, my rpi is slow
		20.wait;
		// array of loops created by superclean
		~arrayOfBuffers = ~clean.buffers[\fields];
		~currentLoop = 0;
		~firstLoop = ~clean.buffers[\fields][0].bufnum;
		~numLoops = ~arrayOfBuffers.size;
		~numLoops.postln;

		// ~irL = ~clean.buffers[\ir][0];
		// ~irR = ~clean.buffers[\ir][1];
		// ~amped = false;
		~bypass = false;
		~playing = true;
	);

	(
		/* i had some trouble with caesarlooper and the
		order of execution, so i added all things into groups*/
		~sourceGroup = Group.new;
		~analysisGroup = Group.after(~sourceGroup);
		~grainGroup = Group.after(~sourceGroup);
		~caesarGroup = Group.after(~grainGroup);
		~mixerGroup = Group.after(~caesarGroup);
	);

	s.sync;

	(

		(
			Ndef(\input, {
				var amp, sig;
				amp = \amp.kr(0.8, 0.01);
				// sig = SoundIn.ar(0) ! 2;
				sig = SoundIn.ar([0, 1]);
				sig * amp;
			}).play(~inputBus, 2, ~sourceGroup)
		);

		(
			Ndef(\tape).addSpec(
				\amp, [0, 1],
				\bufn, [~firstLoop, ~firstLoop + ~numLoops],
				\rate, [0.125, 8],
				\start, [0.0, 1],
				\end, [0.0, 1],
				\lpf, [20, 22050],
				\hpf, [10, 20050],
				\tapeAmp, [0, 1],
				\shiftdistance, [-1, 1],
				\pitch2amp, [0, 1],
			)
		);

		s.sync;

		(
			Ndef(\tape, {
				var amp, bufn, rate, sig, ptr, bufFrames, start, end, lpf, hpf, mix,
				sig2, ptr2, shiftdistance,
				tapeAmp, pitch2amp, pitch3amp, pitch4amp;

				amp = \amp.kr(0.8, 0.01);
				rate = \rate.kr(1, 0.5);//start with 0 or 1?
				bufn = \bufn.kr(~firstLoop, 0).round;
				bufFrames = BufFrames.kr(bufn);
				start = 0 + \start.kr(0, 0.4) * bufFrames;
				end = \end.kr(1, 0.1) * bufFrames;
				lpf = \lpf.kr(22050, 0.2);
				hpf = \hpf.kr(10, 0.2);

				/* new approach: have a shiftdistance to calculate
				how far the other pitches are from the base rate */

				tapeAmp = \tapeAmp.kr(0, 0.01);
				shiftdistance = \shiftdistance.kr(0.0, 0.01);
				pitch2amp = \pitch2amp.kr(0, 0.01);

				ptr = Phasor.ar(
					0,
					rate,
					start,
					end
				);

				sig = BufRd.ar(
					2,
					bufn,
					ptr,
					1.0,
					4
				);

				ptr2 = Phasor.ar(
					0,
					rate + (rate * shiftdistance),
					start,
					end
				);

				sig2 = BufRd.ar(
					2,
					bufn,
					ptr2,
					1.0,
					4
				);

				mix = Mix.ar([sig * tapeAmp, sig2 * pitch2amp]);
				mix = HPF.ar(mix, hpf);
				mix = LPF.ar(mix, lpf);

				mix * amp;
			}).play(~tapeBus, 2, ~sourceGroup);

			// Ndef(\tape).edit
		);

		(
			Ndef(\analysis).addSpec(
				\attack, [0.001, 0.3],
				\release, [0.001, 0.3],
				\threshold, [-100.0, -30.0],
				\hpf, [10, 1000],
				\knee, [0.9, 1.1],
			)
		);

		s.sync;

		(
			Ndef(\analysis, {
				var input, in, e, thresh, c, attack, release, kneelag;
				input = In.ar(~tapeBus, 2);

				attack = \attack.kr(0.01);
				release = \release.kr(0.1);
				thresh = \threshold.kr(-6);
				in = input * \trim.kr(0).dbamp;

				e = in.mean;

				e = HPF.ar( e, \hpf.kr(50) );

				e = EnvDetect.ar(e, attack, release);

				// how much we are over by
				o = e.ampdb.excess(thresh);

				// scale the excess value by ratio
				r = \ratio.kr(4);
				c = ( max(o, 0.0) ) * (r.reciprocal - 1);

				kneelag = attack * \knee.kr(0.0);

				c = c.lag( kneelag );
				c = c.dbamp;

			});

			Ndef('analysis').set('threshold', -58.6, 'release', 0.05, 'knee', 1.01);
			// Ndef(\analysis).edit;

		);

		(
			Ndef(\granular_comp).addSpec(
				\lookahead, [0.0,1],
				\saturate, \switch,
				\lpf, [0.0, 0.2],
				\inAmp, [0.0, 1],
				\tapeAmp, [0.0, 1],
				\cleanAmp, [0.0, 1],
				\wet, [0.0, 1],
				\lookahead, [0.0,4100],
				\rate, [0,1],
				\tFreq, [1, 22050, \exp],
				\overlap, [0.1, 1024.0, \exp],
				\hpf, \freq,
				\wet, [0.0,1],
				\dry, [0.0,1],
				\gain, [0.0,40],
				\drop, [0, 90],
				\modReadPos, [0.001, 0.01],
				\modRate, [0.01, 0.1],
				\modTFreq, [0.1, 10],
				\modOverlap, [0.1, 10]
			)
		);

		s.sync;

		(
			Ndef(\granular_comp, {
				arg	inAmp = 0, tapeAmp = 1, cleanAmp = 0, gain = 0, lookahead = 0, tFreq = 20, overlap = 2, rate = 1, lpf = 0, drop = 0, modReadPos = 0, modRate = 0,
				modOverlap = 0, modTFreq = 0;

				var input, readPos, signal, writePos, grained, balance, t, bufFrames, buf, bufdur, sc;

				bufFrames = 2**16;
				buf = {LocalBuf(bufFrames).clear}!2;
				bufdur = BufDur.ir(buf);

				writePos = Phasor.ar(
					0,
					rate,
					0,
					bufFrames
				);

				input = Mix.ar([In.ar(~inputBus, 2) * inAmp, In.ar(~tapeBus, 2) * tapeAmp]);
				input = WaveLoss.ar(input, drop, 100, 2);
				// writing input to grain buffer
				buf.do {
					arg b, i;
					BufWr.ar( input[i], b, writePos)
				};

				t = Impulse.ar(tFreq + modTFreq.lag(0.1));

				readPos = Wrap.ar(
					writePos - 64 - lookahead / bufFrames,
					0,
					1
				);

				sc = Ndef(\analysis).ar;

				// maybe change this to stereo at some point
				grained = GrainBufJ.ar(
					numChannels:1,
					loop: 1,
					trigger:t,
					// dur: overlap / tFreq,
					dur: sc * (overlap + modOverlap.lag(0.1)) / tFreq,
					sndbuf: buf,
					rate: rate - lpf + modRate.lag(0.1),
					pos: readPos + modReadPos.lag(0.1),
					interp: 4,
					// grainAmp: sc,
					pan: 0,
					envbufnum: -1,
					maxGrains: 2048,
				);

				grained = HPF.ar( grained, \hpf.kr(40) );

				signal = Mix([
					LeakDC.ar( grained ) * \wet.kr(0),
					DelayC.ar(
						input,
						0.5,
						(64 + lookahead / SampleRate.ir )
					) * \dry.kr(1),
					In.ar(~cleanBus, 2) * cleanAmp
				]) * gain.dbamp;

				signal.tanh

			}).play(~mixerBus, 2, ~grainGroup);

			// Ndef(\granular_comp).edit

		);

		s.sync;

		(
			{
				// caesar needs a bit of patience
				~caesar = CaesarLooper(~mixerBus, ~caesarBus, 16, ~caesarGroup);
				9.wait;
				~caesar.inputLevel_(0);
				1.wait;
				~caesar.dryLevel_(0);
				1.wait;
				~caesar.delay_(16);
				1.wait;
				~caesar.effectLevel_(1);
				1.wait;
				~caesar.masterFeedback_(0);
				5.wait;
				~caesar.clear;
			}.fork;
		);

		s.sync;

		(
			Ndef(\mixer).addSpec(
				\finalAmp, [0.0, 1],
				\caesarAmp, [0.0, 1],
				\reverbAmp, [-1.0, 1.0],
				\damp, [0.0, 1],
			)
		);

		s.sync;

		(

			Ndef(\mixer, {
				arg finalAmp = 0.5, caesarAmp = 0.0, reverbAmp = -1.0;
				var sig, reverb;

				sig = Mix.ar([In.ar(~mixerBus, 2), In.ar(~caesarBus, 2) * caesarAmp/*, In.ar(~cleanBus, 2)*/]);

				// end of chain reverb

				reverb = Mix.ar([
					GVerb.ar(sig[0], 150, 1, \damp.kr(0.5, 0.5), 0.0, 15, 0.0, 0.7, 0.5),
					GVerb.ar(sig[1], 150, 1, \damp.kr(0.5, 0.5), 0.0, 15, 0.0, 0.7, 0.5)
				]);

				reverb = LPF.ar(reverb, 2200);

				/* reverb = Greyhole.ar(sig, \delayTime.kr(2), \damp.kr(0), \size.kr(1),
				\diff.kr(0.707), \feedback.kr(0.9), \modDepth.kr(0.1), \modFreq.kr(0.61)); */

				sig = XFade2.ar(sig, reverb, reverbAmp);

				sig * finalAmp;
			}).play(0, 2, ~mixerGroup);

			// Ndef(\mixer).edit

		);

		s.sync;
		// just in case, this might get loud
		StageLimiter.activate;

		(
			// midi control things
			m = MKtl('mm',"akai-midimix");
			// m = MKtl('mm',"akai-hermod");
			10.wait;

			//give all the midimix controls names
			MKtl(\mm).addNamed(\knob1, MKtl(\mm).elAt(\kn,0,0));
			MKtl(\mm).addNamed(\knob2, MKtl(\mm).elAt(\kn,0,1));
			MKtl(\mm).addNamed(\knob3, MKtl(\mm).elAt(\kn,0,2));
			MKtl(\mm).addNamed(\knob4, MKtl(\mm).elAt(\kn,0,3));
			MKtl(\mm).addNamed(\knob5, MKtl(\mm).elAt(\kn,0,4));
			MKtl(\mm).addNamed(\knob6, MKtl(\mm).elAt(\kn,0,5));
			MKtl(\mm).addNamed(\knob7, MKtl(\mm).elAt(\kn,0,6));
			MKtl(\mm).addNamed(\knob8, MKtl(\mm).elAt(\kn,0,7));
			MKtl(\mm).addNamed(\knob9, MKtl(\mm).elAt(\kn,1,0));
			MKtl(\mm).addNamed(\knob10, MKtl(\mm).elAt(\kn,1,1));
			MKtl(\mm).addNamed(\knob11, MKtl(\mm).elAt(\kn,1,2));
			MKtl(\mm).addNamed(\knob12, MKtl(\mm).elAt(\kn,1,3));
			MKtl(\mm).addNamed(\knob13, MKtl(\mm).elAt(\kn,1,4));
			MKtl(\mm).addNamed(\knob14, MKtl(\mm).elAt(\kn,1,5));
			MKtl(\mm).addNamed(\knob15, MKtl(\mm).elAt(\kn,1,6));
			MKtl(\mm).addNamed(\knob16, MKtl(\mm).elAt(\kn,1,7));
			MKtl(\mm).addNamed(\knob17, MKtl(\mm).elAt(\kn,2,0));
			MKtl(\mm).addNamed(\knob18, MKtl(\mm).elAt(\kn,2,1));
			MKtl(\mm).addNamed(\knob19, MKtl(\mm).elAt(\kn,2,2));
			MKtl(\mm).addNamed(\knob20, MKtl(\mm).elAt(\kn,2,3));
			MKtl(\mm).addNamed(\knob21, MKtl(\mm).elAt(\kn,2,4));
			MKtl(\mm).addNamed(\knob22, MKtl(\mm).elAt(\kn,2,5));
			MKtl(\mm).addNamed(\knob23, MKtl(\mm).elAt(\kn,2,6));
			MKtl(\mm).addNamed(\knob24, MKtl(\mm).elAt(\kn,2,7));

			MKtl(\mm).addNamed(\button1, MKtl(\mm).elAt(\bt,0,0,0));
			MKtl(\mm).addNamed(\button2, MKtl(\mm).elAt(\bt,0,1,0));
			MKtl(\mm).addNamed(\button3, MKtl(\mm).elAt(\bt,0,2,0));
			MKtl(\mm).addNamed(\button4, MKtl(\mm).elAt(\bt,0,3,0));
			MKtl(\mm).addNamed(\button5, MKtl(\mm).elAt(\bt,0,4,0));
			MKtl(\mm).addNamed(\button6, MKtl(\mm).elAt(\bt,0,5,0));
			MKtl(\mm).addNamed(\button7, MKtl(\mm).elAt(\bt,0,6,0));
			MKtl(\mm).addNamed(\button8, MKtl(\mm).elAt(\bt,0,7,0));

			MKtl(\mm).addNamed(\button9, MKtl(\mm).elAt(\bt,1,0,0));
			MKtl(\mm).addNamed(\button10, MKtl(\mm).elAt(\bt,1,1,0));
			MKtl(\mm).addNamed(\button11, MKtl(\mm).elAt(\bt,1,2,0));
			MKtl(\mm).addNamed(\button12, MKtl(\mm).elAt(\bt,1,3,0));
			MKtl(\mm).addNamed(\button13, MKtl(\mm).elAt(\bt,1,4,0));
			MKtl(\mm).addNamed(\button14, MKtl(\mm).elAt(\bt,1,5,0));
			MKtl(\mm).addNamed(\button15, MKtl(\mm).elAt(\bt,1,6,0));
			MKtl(\mm).addNamed(\button16, MKtl(\mm).elAt(\bt,1,7,0));

			// the hidden buttons
			MKtl(\mm).addNamed(\button17, MKtl(\mm).elAt(\bt,2,0,0));
			MKtl(\mm).addNamed(\button18, MKtl(\mm).elAt(\bt,2,1,0));
			MKtl(\mm).addNamed(\button19, MKtl(\mm).elAt(\bt,2,2,0));
			MKtl(\mm).addNamed(\button20, MKtl(\mm).elAt(\bt,2,3,0));
			MKtl(\mm).addNamed(\button21, MKtl(\mm).elAt(\bt,2,4,0));
			MKtl(\mm).addNamed(\button22, MKtl(\mm).elAt(\bt,2,5,0));
			MKtl(\mm).addNamed(\button23, MKtl(\mm).elAt(\bt,2,6,0));
			MKtl(\mm).addNamed(\button24, MKtl(\mm).elAt(\bt,2,7,0));

			MKtl(\mm).addNamed(\slider1, MKtl(\mm).elAt(\sl,0));
			MKtl(\mm).addNamed(\slider2, MKtl(\mm).elAt(\sl,1));
			MKtl(\mm).addNamed(\slider3, MKtl(\mm).elAt(\sl,2));
			MKtl(\mm).addNamed(\slider4, MKtl(\mm).elAt(\sl,3));
			MKtl(\mm).addNamed(\slider5, MKtl(\mm).elAt(\sl,4));
			MKtl(\mm).addNamed(\slider6, MKtl(\mm).elAt(\sl,5));
			MKtl(\mm).addNamed(\slider7, MKtl(\mm).elAt(\sl,6));
			MKtl(\mm).addNamed(\slider8, MKtl(\mm).elAt(\sl,7));
			MKtl(\mm).addNamed(\slider9, MKtl(\mm).elAt(\sl,8));

			MKtl(\mm).addNamed(\bankleft, MKtl(\mm).elAt(\bankLeft,0));
			MKtl(\mm).addNamed(\bankright, MKtl(\mm).elAt(\bankRight,0));

			/* this is a 5-bit binary "display" to have some feedback
			when scrolling through the buffers on the disk */
			~showCurrentLoop = {
				var binArray;
				binArray = ~currentLoop.asBinaryDigits(6).reverse;
				MKtl(\mm).elAt(\bt,1,2,0).value_(binArray[0].linlin(0,1,0,127));
				MKtl(\mm).elAt(\bt,1,3,0).value_(binArray[1].linlin(0,1,0,127));
				MKtl(\mm).elAt(\bt,1,4,0).value_(binArray[2].linlin(0,1,0,127));
				MKtl(\mm).elAt(\bt,1,5,0).value_(binArray[3].linlin(0,1,0,127));
				MKtl(\mm).elAt(\bt,1,6,0).value_(binArray[4].linlin(0,1,0,127));
			};

			// define what the actions actually do
			~controls = (
				actions: (
					//buttons
					selectBefore: {
						MKtl(\mm).elAt(\bt,1,0,0).value_(127);
						~currentLoop = ~currentLoop-1%~numLoops;
						~showCurrentLoop.value;
						Ndef(\tape).set(\bufn, ~arrayOfBuffers[~currentLoop]);
						MKtl(\mm).elAt(\bt,1,0,0).value_(0);
					},
					selectNext: {
						MKtl(\mm).elAt(\bt,1,1,0).value_(127);
						~currentLoop = ~currentLoop+1%~numLoops;
						~showCurrentLoop.value;
						Ndef(\tape).set(\bufn,~arrayOfBuffers[~currentLoop]);
						MKtl(\mm).elAt(\bt,1,1,0).value_(0);
					},
					tapLength: { ~caesar.tapLength;},
					record: { if (~caesar.inputLevel == 1,
						{ MKtl(\mm).elAt(\bt,0,5,0).value_(0);
							~caesar.inputLevel_(0);
						}, { MKtl(\mm).elAt(\bt,0,5,0).value_(127);
							~caesar.inputLevel_(1);
					});},
					reverse: { ~caesar.reverse;},
					freeze: { if (~caesar.isFrozen,
						{ MKtl(\mm).elAt(\bt,0,7,0).value_(0);
							~caesar.freeze;
						}, { MKtl(\mm).elAt(\bt,0,7,0).value_(127);
							~caesar.freeze;
					});},
					// beware: adding readheads may make a feedback mess, use with caution
					// addReadHead: { if(~caesar.reads[7]==nil,{~caesar.addRead(~nextReadDiv,~nextReadLevel,rrand(-0.05,0.05));},{"too many read heads".postln;});},
					// removeReadHead: { if(~caesar.reads[1]==nil,{"don't want to remove the main read head".postln;},{~caesar.removeRead;});},

					// tapestuff
					setTapeSpeed: { |el| if(~playing,{
						Ndef(\tape).set(\rate, el.value.linexp(0, 1, 0.125, 8));
					},{})},
					setTapeStart: { |el| Ndef(\tape).set(\start, el.value); },
					setTapeEnd: { |el| Ndef(\tape).set(\end, el.value); },
					setTapeLowpass: { |el|
						Ndef(\tape).set(\lpf, el.value.linlin(0, 1, 20, 22050));
						~cleanLowpass = el.value.linlin(0, 1, 20, 20000);
					},
					setTapeHighpass: { |el|
						Ndef(\tape).set(\hpf, el.value.linlin(0, 1, 10, 20050));
						~cleanHipass = el.value.linlin(0, 1, 20, 20000);
					},
					setDrop: { |el| Ndef(\granular_comp).set(\drop, el.value.linlin(0, 1, 0, 90)); },

					// analysis & grancomp
					setAnalysisHighpass: { |el| Ndef(\analysis).set(\hpf, el.value.linexp(0, 1, 10, 1000)); },
					setAnalysisAttack: { |el| Ndef(\analysis).set(\attack, el.value.linlin(0, 1, 0.001, 0.2)); },
					setAnalysisRelease: { |el| Ndef(\analysis).set(\release, el.value.linlin(0, 1, 0.001, 0.3)); },
					setAnalysisThreshold: { |el| Ndef(\analysis).set(\threshold, el.value.linlin(0, 1, -100.0, -30.0)); },
					setAnalysisKnee: { |el| Ndef(\analysis).set(\knee, el.value.linlin(0, 1, 0.9, 1.1)); },

					setGranLookahead: { |el| Ndef(\granular_comp).set(\lookahead, el.value.linlin(0, 1, 0, 4100)); },
					setGranLowpass: { |el| Ndef(\granular_comp).set(\lpf, el.value.linlin(0, 1, 0.0, 0.2)); },
					setGranHighpass: { |el| Ndef(\granular_comp).set(\hpf, el.value.linexp(0, 1, 10, 22050)); },
					setGranGain: { |el| Ndef(\granular_comp).set(\gain, el.value.linlin(0, 1, 0.0, 40.0)); },
					setGranRate: { |el| Ndef(\granular_comp).set(\rate, el.value); },
					setGranTFreq: { |el| Ndef(\granular_comp).set(\tFreq, el.value.linexp(0, 1, 1, 22050)); },
					setGranOverlap: { |el| Ndef(\granular_comp).set(\overlap, el.value.linexp(0, 1, 0.1, 1024.0)); },
					setAnalysisRatio: { |el| Ndef(\analysis).set(\ratio, el.value.linlin(0, 1, 1.0, 4.0)); },

					// caesarstuff
					setCaesarPitch: { |el| ~caesar.pitch_(el.value.linlin(0,1,-4,4));},
					setCaesarFeedback: { |el| ~caesar.masterFeedback_(el.value);},

					// chord action
					setShiftDistance: { |el| Ndef(\tape).set(\shiftdistance, el.value.linlin(0, 1, -1, 1)); },
					setPitch2Amp: { |el| Ndef(\tape).set(\pitch2amp, el.value); },

					// reverb
					// setReverbDamping: { |el| Ndef(\reverb).set(\damp, el.value); },
					setReverbLevel: { |el| Ndef(\mixer).set(\reverbAmp, el.value.linlin(0, 1, -1.0, 1.0)); },

					// vols
					setInAmp: { |el| Ndef(\granular_comp).set(\inAmp, el.value); },
					setInAmpBypass: { |el| Ndef(\input).set(\amp, el.value.linlin(0, 1, 0, 0.8)); },
					setTapeAmp: { |el| Ndef(\tape).set(\tapeAmp, el.value); },
					setDryAmp: { |el| Ndef(\granular_comp).set(\dry, el.value); },
					setGrainAmp: { |el| Ndef(\granular_comp).set(\wet, el.value); },
					setCaesarAmp: { |el| Ndef(\mixer).set(\caesarAmp, el.value); },
					setFinalAmp: { |el| Ndef(\mixer).set(\finalAmp, el.value); },

					playTape: { |el| if (~playing,{
						~playing = false;
						MKtl(\mm).elAt(\bt,0,1,0).value_(0);
						Ndef(\tape).set(\rate, 0);
					},{
						~playing = true;
						MKtl(\mm).elAt(\bt,0,1,0).value_(127);
						m.elementAt(\knob1).doAction;
					})},

					bypass: { |el| if (~bypass,{
						Ndef(\input, {
							var amp, sig;
							amp = \amp.kr(0.8, 0.01);
							// sig = SoundIn.ar(0) ! 2;
							sig = SoundIn.ar([0, 1]);
							sig * amp;
						}).play(~inputBus, 2, ~sourceGroup);
						MKtl(\mm).elAt(\bt,0,0,0).value_(0);
						MKtl(\mm).elAt(\slider1).postln.action = ~controls.actions[\setInAmp.postln].postln;
						~bypass = false;
					},{
						Ndef(\input, {
							var amp, sig;
							amp = \amp.kr(0.8, 0.01);
							// sig = SoundIn.ar(0) ! 2;
							sig = SoundIn.ar([0, 1]);
							sig * amp;
						}).play(0, 2, ~sourceGroup);
						MKtl(\mm).elAt(\bt,0,0,0).value_(127);
						MKtl(\mm).elAt(\slider1).postln.action = ~controls.actions[\setInAmpBypass.postln].postln;
						~bypass = true;
					}
					);},
					playClean: { |el|
						if(~cleanPlays, {
							Pdef(0).stop;
							~cleanPlays = false;
							MKtl(\mm).elAt(\bt,0,2,0).value_(0);
						},{
							Pdef(0).play;
							~cleanPlays = true;
							MKtl(\mm).elAt(\bt,0,2,0).value_(127);
					});},
					randomizeClean: { |el|
						~seed = 2147483647.rand;
						~t_cleanGate = true;
					},
					setCleanAmp: { |el| Ndef(\granular_comp).set(\cleanAmp, el.value); },
					setCleanSpeed: { |el| ~cleanSpeed = el.value.linlin(0, 1, 10, 0.01); },
					setCleanMod: { |el| ~cleanMod = el.value.linlin(0, 1, -1, 1); },

					toggleModTapeRate: { |el|
						if(~modTapeRate, {
							~modTapeRate = false;
							MKtl(\mm).elAt(\bt,2,0,0).value_(0);
						},{
							~modTapeRate = true;
							MKtl(\mm).elAt(\bt,2,0,0).value_(127);
					});},

					toggleModTapePos: { |el|
						if(~modTapePos, {
							~modTapePos = false;
							MKtl(\mm).elAt(\bt,2,1,0).value_(0);
						},{
							~modTapePos = true;
							MKtl(\mm).elAt(\bt,2,1,0).value_(127);
					});},
					toggleModLoopPitch: { |el|
						if(~modLoopPitch, {
							~modLoopPitch = false;
							MKtl(\mm).elAt(\bt,2,2,0).value_(0);
						},{
							~modLoopPitch = true;
							MKtl(\mm).elAt(\bt,2,2,0).value_(127);
					});},
					toggleModLoopFeedback: { |el|
						if(~modLoopFeedback, {
							~modLoopFeedback = false;
							MKtl(\mm).elAt(\bt,2,3,0).value_(0);
						},{
							~modLoopFeedback = true;
							MKtl(\mm).elAt(\bt,2,3,0).value_(127);
					});},
					toggleModGrainRate: { |el|
						if(~modGrainRate, {
							~modGrainRate = false;
							MKtl(\mm).elAt(\bt,2,4,0).value_(0);
						},{
							~modGrainRate = true;
							MKtl(\mm).elAt(\bt,2,4,0).value_(127);
					});},
					toggleModTFreq: { |el|
						if(~modGrainTFreq, {
							~modGrainTFreq = false;
							MKtl(\mm).elAt(\bt,2,5,0).value_(0);
						},{
							~modGrainTFreq = true;
							MKtl(\mm).elAt(\bt,2,5,0).value_(127);
					});},
					toggleModOverlap: { |el|
						if(~modGrainOverlap, {
							~modGrainOverlap = false;
							MKtl(\mm).elAt(\bt,2,6,0).value_(0);
						},{
							~modGrainOverlap = true;
							MKtl(\mm).elAt(\bt,2,6,0).value_(127);
					});},
					toggleModGrainPos: { |el|
						if(~modGrainPos, {
							~modGrainPos = false;
							MKtl(\mm).elAt(\bt,2,7,0).value_(0);
						},{
							~modGrainPos = true;
							MKtl(\mm).elAt(\bt,2,7,0).value_(127);
					});},


			));

			// sort out which control gets which action
			~controls.put(
				\mm, (
					\ctlMap1: (
						\button1: \bypass,
						\button2: \playTape,

						\button3: \playClean,
						\button4: \randomizeClean,

						\button5: \tapLength,
						\button6: \record,
						\button7: \reverse,
						\button8: \freeze,
						\button9: \selectBefore,
						\button10: \selectNext,

						// mod targets:
						\button17: \toggleModTapeRate,
						\button18: \toggleModTapePos,
						\button19: \toggleModLoopPitch,
						\button20: \toggleModLoopFeedback,
						\button21: \toggleModGrainRate,
						\button22: \toggleModTFreq,
						\button23: \toggleModOverlap,
						\button24: \toggleModGrainPos,

						// tapestuff
						\knob1: \setTapeSpeed,
						\knob2: \setTapeStart,
						\knob3: \setTapeEnd,

						// analysis & granular
						\knob4: \setAnalysisHighpass,
						\knob5: \setAnalysisAttack,
						\knob6: \setAnalysisRelease,
						\knob7: \setAnalysisThreshold,
						\knob8: \setAnalysisKnee,
						\knob9: \setGranLookahead,
						\knob10: \setGranLowpass,
						\knob11: \setGranHighpass,
						\knob12: \setGranGain,
						\knob13: \setGranRate,
						\knob14: \setGranTFreq,
						\knob15: \setGranOverlap,
						\knob16: \setAnalysisRatio,

						// again some tapestuff
						\knob17: \setTapeLowpass,
						\knob18: \setTapeHighpass,

						// caesarstuff
						\knob19: \setCaesarPitch,
						\knob20: \setCaesarFeedback,

						// the waveloss
						\knob21: \setDrop,

						// chordstuff
						\knob22: \setShiftDistance,

						//reverb
						// \knob23: \setReverbDamping,
						// \knob24: \setReverbLevel,
						\knob23: \setCleanSpeed,
						\knob24: \setCleanMod,

						// volumes
						\slider1: \setInAmp,
						\slider2: \setTapeAmp,
						\slider3: \setDryAmp,
						\slider4: \setGrainAmp,
						\slider5: \setCaesarAmp,
						\slider6: \setPitch2Amp,
						\slider7: \setCleanAmp,
						\slider8: \setReverbLevel,
						\slider9: \setFinalAmp
					)
				)
			);

			~controls.mm.ctlMap1.keysValuesDo { |elName, actName|
				MKtl(\mm).elAt(elName).postln.action = ~controls.actions[actName.postln].postln;
			};
			// m.gui;
		);

		(
			// reset lights
			3.do({arg i;
				8.do({arg j;
					MKtl(\mm).elAt(\bt,i,j,0).value_(0);
				});
			});

			// change values to corresponding knob and sliders
			24.do({
				arg i;
				m.elementAt((\knob ++ (i+1)).asSymbol).doAction;
			});

			9.do({
				arg i;
				m.elementAt((\slider ++ (i+1)).asSymbol).doAction;
			});

			// tape is playing by default
			MKtl(\mm).elAt(\bt,0,1,0).value_(127);
		);

		Pdef(0,
			Pbind(*[
				segments: Pfunc{~segments},
				timeframe: Pdup(inf, Pwhite(1, 4)),
				seed: Pfunc{~seed},
				type: \cln,
				snd: \from,
				in: ~tapeBus,
				cleanSpeed: Pfunc{~cleanSpeed},
				cleanMod: Pfunc{~cleanMod},
				gate: Pfunc{~t_cleanGate},
				speed: Pfunc{~speed} * Pgate(Pwhite(1, 10), inf, \gate),
				// length: Pfunc { arg event; ~clean.buffers[\fields][~currentLoop].numFrames / ~clean.buffers[\fields][event.num].sampleRate; } / Pkey(\speed),
				length: Pfunc{~length},
				single: Pkey(\length) / Pkey(\segments),
				dur: Pkey(\cleanSpeed),
				//calculate random, but really repeating movements!
				mod1: Pn(Plazy{
					var length = 13.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0,5,length) * Pkey(\cleanMod));
				})/* + (Pseg([0, 1, 0], Pkey(\dur) * Pkey(\timeframe), \sin, inf) * Pkey(\cleanMod))*/,
				mod2: Pn(Plazy{
					var length = 11.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0,100,length) * Pkey(\cleanMod));
				}),
				mod3: Pn(Plazy{
					var length = 15.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0.1,0.5,length) * Pkey(\cleanMod));
				}),
				mod4: Pn(Plazy{
					var length = 9.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0.01,0.3,length) * Pkey(\cleanMod));
				}),
				mod5: Pn(Plazy{
					var length = 12.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0.1,0.5,length) * Pkey(\cleanMod));
				}),
				mod6: Pn(Plazy{
					var length = 13.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0,2000,length) * Pkey(\cleanMod));
				}),
				mod7: Pn(Plazy{
					var length = 11.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0,150,length) * Pkey(\cleanMod));
				}),
				mod8: Pn(Plazy{
					var length = 14.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0,100,length) * Pkey(\cleanMod));
				}),

				//apply modifiers to parts of the ndefs and signal chain... 8 targets, SOLO + KEY buttons?
				//TODO some scalings are not applied correctly here, fix later

				fmod1: Pfunc{ arg event; if(~modTapeRate,{
					Ndef(\tape).set(\rate, MKtl(\mm).elAt(\kn,0,0).value.linexp(0, 1, 0.125, 8) + event.mod1);
					"1 change to"++event.mod1.value.postln;
				},{"1 no change".postln;}); },
				fmod2: Pfunc{ arg event; if(~modTapePos,{
					Ndef(\tape).set(\start, (MKtl(\mm).elAt(\kn,0,1).value + event.mod2).abs % 1);
					"2 change to"++event.mod2.value.postln;
				},{"2 no change".postln;}); },
				fmod3: Pfunc{ arg event; if(~modLoopPitch,{
					~caesar.pitch_(MKtl(\mm).elAt(\kn,2,2).value.linlin(0,1,-4,4) + event.mod3);
					"3 change to"++event.mod3.value.postln;
				},{"3 no change".postln;}); },
				fmod4: Pfunc{ arg event; if(~modLoopFeedback,{
					~caesar.masterFeedback_(MKtl(\mm).elAt(\kn,2,3).value + event.mod4);
					"4 change to"++event.mod4.value.postln;
				},{"4 no change".postln;}); },

				//i guess it's possible to break this with some values, need to
				//investigate and catch all wrongdoings

				fmod5: Pfunc{ arg event; if(~modGrainRate,{
					Ndef(\granular_comp).set(\modRate, event.mod5);
					"5 change to"++event.mod5.value.postln;
				},{"5 no change".postln;}); },
				fmod6: Pfunc{ arg event; if(~modGrainTFreq,{
					Ndef(\granular_comp).set(\modTFreq, event.mod6);
					"6 change to"++event.mod6.value.postln;
				},{"6 no change".postln;}); },
				fmod7: Pfunc{ arg event; if(~modGrainOverlap,{
					Ndef(\granular_comp).set(\modOverlap, event.mod7);
					"7 change to"++event.mod7.value.postln;
				},{"7 no change".postln;}); },
				fmod8: Pfunc{ arg event; if(~modGrainPos,{
					Ndef(\granular_comp).set(\modReadPos, event.mod8);
					"8 change to"++event.mod8.value.postln;
				},{"8 no change".postln;}); },

				atk: Pkey(\dur) / 3 + Pwhite(0.01, 0.04),
				rel: Pkey(\dur) / 3 + Pwhite(0.01, 0.04),

				legato: Pkey(\dur) * 5,
				hld: Pkey(\dur) * 5,

				amp: 0.1,
				rma: 0.5 + Pwhite(0.01, 0.07),
				rmf: 300 + Pkey(\mod6),

				// smr: 0.3,
				// scm: 0.3,
				// enh: 0.2,

				// util: Pfunc{arg event; event.dur.postln;},
				out: ~cleanBus,
		]));
	);

);

}

)
// s.record;
