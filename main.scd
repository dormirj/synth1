(
s.waitForBoot{(
	(
		~tapeBus = Bus.audio(s, 2);
		~inputBus = Bus.audio(s, 2);
		~mixerBus = Bus.audio(s, 2);
		~caesarBus = Bus.audio(s, 2);
		// ~phasorBus = Bus.audio(s, 1);

		// variables for autogenerated clean pattern
		// ~cleanBus = Bus.audio(s, 2);
		~cleanPlays = false;

		~cleanLo = 20000;
		~cleanHi = 16;

		// ~cleanAmp = 0;

		// ~cleanSpeed = 1;
		~speedDivider = 1.0;
		~cleanMod = 0;
		~masterSlew = 0; //general slew rate for "relevant" changes to ndefs

		~seed = 2147483647.rand;
		// ~t_cleanGate = false;
		//values for the clean sequencer:v:
		~degrees = [0, 0, 0, 0, 0, 0, 0, 0];
		~durs = [1, 1, 1, 1, 1, 1, 1, 1];
		~amps = [1, 1, 1, 1, 1, 1, 1, 1];
		~influence = [0, 0, 0, 0];
		~legato = 1;
		~traverse = 100;
		~atk = 0.01;
		~rel = 1;
		~cleanLoop = 0;
		~tnh= 0.1;

		// mod targets on/off switches
		~modTapeRate = false;
		~modTapePos = false;
		~modLoopPitch = false;
		~modLoopFeedback = false;
		~modGrainRate = false;
		~modGrainTFreq = false;
		~modGrainOverlap = false;
		~modGrainPos = false;

		// added a little waiting time, my rpi is slow
		20.wait;
		// array of loops created by superclean
		~arrayOfBuffers = ~clean.buffers[\fields];
		~currentLoop = 0;
		~firstLoop = ~clean.buffers[\fields][0].bufnum;
		~numLoops = ~arrayOfBuffers.size;
		~numLoops.postln;

		~bypass = false;
		~playing = true;
	);

	(
		/* i had some trouble with caesarlooper and the
		order of execution, so i added all things into groups*/
		~sourceGroup = Group.new;
		~analysisGroup = Group.after(~sourceGroup);
		~grainGroup = Group.after(~sourceGroup);
		~caesarGroup = Group.after(~grainGroup);
		~mixerGroup = Group.after(~caesarGroup);
		// TODO add some rewrite functionality into the playing buffer
		// ~writerGroup = Group.after(~mixerGroup);

		// TODO other option would be to write the caesarloop into
		// a new buffer that gets concatenated and reload clean samples?
	);

	s.sync;

	(

		(
			Ndef(\input, {
				var amp, sig;
				amp = \amp.kr(0.8, 0.01);
				sig = SoundIn.ar(0) ! 2; //mono in > stereo
				// sig = SoundIn.ar([0, 1]); //stereo in > stereo
				sig * amp;
			}).play(~inputBus, 2, ~sourceGroup)
		);

		(
			Ndef(\tape).addSpec(
				\amp, [0, 1],
				\bufn, [~firstLoop, ~firstLoop + ~numLoops],
				\rate, [0.125, 8],
				\start, [0.0, 1],
				\end, [0.0, 1],
				\lpf, [20, 22050],
				\hpf, [10, 20050],
				\tapeAmp, [0, 1],
				\shiftdistance, [-1, 1],
				\pitch2amp, [0, 1],
				\pitch3amp, [0, 1],
				\slewing, [0, 20],
			)
		);

		s.sync;

		(
			Ndef(\tape, {
				var amp, bufn, rate, sig, ptr, bufFrames, start, end, lpf, hpf, mix,
				sig2, sig3, ptr3, ptr2, shiftdistance, tapeAmp, pitch2amp, pitch3amp,
				slewing;

				amp = \amp.kr(0.8, 0.01);
				rate = \rate.kr(1, 0.5);//start with 0 or 1?
				bufn = \bufn.kr(~firstLoop, 0).round;
				bufFrames = BufFrames.kr(bufn);
				start = 0 + \start.kr(0, 0.4) * bufFrames;
				end = \end.kr(1, 0.1) * bufFrames;
				lpf = \lpf.kr(22050, 0.2);
				hpf = \hpf.kr(10, 0.2);
				slewing = \slewing.kr(~masterSlew, 0.01);

				/* new approach: have a shiftdistance to calculate
				how far the other pitches are from the base rate */

				tapeAmp = \tapeAmp.kr(0, 0.01);
				shiftdistance = \shiftdistance.kr(0.1, 0.01);
				pitch2amp = \pitch2amp.kr(0, 0.01);
				pitch3amp = \pitch3amp.kr(0, 0.01);

				ptr = Phasor.ar(
					0,
					Lag.kr(rate, slewing),
					Lag.kr(start, slewing),
					end
				);

				// Out.ar(~phasorBus, ptr);

				sig = BufRd.ar(
					2,
					bufn,
					ptr,
					1.0,
					4
				);

				ptr2 = Phasor.ar(
					0,
					Lag.kr(rate, slewing) + (Lag.kr(rate, slewing) * shiftdistance),
					Lag.kr(start, slewing),
					end
				);

				sig2 = BufRd.ar(
					2,
					bufn,
					ptr2,
					1.0,
					4
				);

				ptr3 = Phasor.ar(
					0,
					Lag.kr(rate, slewing) - (Lag.kr(rate, slewing) * shiftdistance),
					Lag.kr(start, slewing),
					end
				);

				sig3 = BufRd.ar(
					2,
					bufn,
					ptr3,
					1.0,
					4
				);

				mix = Mix.ar([sig * tapeAmp, sig2 * pitch2amp, sig3 * pitch3amp]);
				mix = HPF.ar(mix, hpf);
				mix = LPF.ar(mix, lpf);

				mix * amp;
			}).play(~tapeBus, 2, ~sourceGroup);

			// Ndef(\tape).edit
		);

		(
			Ndef(\analysis).addSpec(
				\attack, [0.001, 0.3],
				\release, [0.001, 0.3],
				\threshold, [-100.0, -30.0],
				\hpf, [10, 1000],
				\knee, [0.9, 1.1],
			)
		);

		s.sync;

		(
			Ndef(\analysis, {
				var input, in, e, thresh, c, attack, release, kneelag;
				input = In.ar(~tapeBus, 2);

				attack = \attack.kr(0.01);
				release = \release.kr(0.1);
				thresh = \threshold.kr(-6);
				in = input * \trim.kr(0).dbamp;

				e = in.mean;

				e = HPF.ar( e, \hpf.kr(50) );

				e = EnvDetect.ar(e, attack, release);

				// how much we are over by
				o = e.ampdb.excess(thresh);

				// scale the excess value by ratio
				r = \ratio.kr(4);
				c = ( max(o, 0.0) ) * (r.reciprocal - 1);

				kneelag = attack * \knee.kr(0.0);

				c = c.lag( kneelag );
				c = c.dbamp;

			});

			Ndef('analysis').set('threshold', -58.6, 'release', 0.05, 'knee', 1.1);
			// Ndef(\analysis).edit;

		);

		(
			Ndef(\granular_comp).addSpec(
				\lookahead, [0.0,1],
				\lpf, [0.0, 0.2],
				\inAmp, [0.0, 1],
				\tapeAmp, [0.0, 1],
				\cleanAmp, [0.0, 1],
				\wet, [0.0, 1],
				\lookahead, [0.0,4100],
				\rate, [0,1],
				\tFreq, [1, 22050, \exp],
				\overlap, [0.1, 1024.0, \exp],
				\hpf, \freq,
				\wet, [0.0,1],
				\dry, [0.0,1],
				\gain, [0.0,40],
				\drop, [0, 90],
				\modReadPos, [0.001, 0.01],
				\modRate, [0.01, 0.1],
				\modTFreq, [0.1, 10],
				\modOverlap, [0.1, 10],
				\slewing, [0, 20],
			)
		);

		s.sync;

		(
			Ndef(\granular_comp, {
				arg	inAmp = 0, tapeAmp = 1, cleanAmp = 0, gain = 0, lookahead = 0, tFreq = 20,
				overlap = 2, rate = 1, lpf = 0, drop = 0, modReadPos = 0, modRate = 0,
				modOverlap = 0, modTFreq = 0;

				var input, readPos, signal, writePos, grained, balance, t, bufFrames, buf, bufdur, sc, slewing;

				bufFrames = 2**16;
				buf = {LocalBuf(bufFrames).clear}!2;
				bufdur = BufDur.ir(buf);
				slewing = \slewing.kr(~masterSlew, 0.01);

				writePos = Phasor.ar(
					0,
					rate,
					0,
					bufFrames
				);

				input = Mix.ar([In.ar(~inputBus, 2) * inAmp, In.ar(~tapeBus, 2) * tapeAmp]);
				input = WaveLoss.ar(input, drop, 100, 2);
				// writing input to grain buffer
				buf.do {
					arg b, i;
					BufWr.ar( input[i], b, writePos)
				};

				t = Impulse.ar(tFreq + modTFreq.lag(slewing));

				readPos = Wrap.ar(
					writePos - 64 - lookahead / bufFrames,
					0,
					1
				);

				sc = Ndef(\analysis).ar;

				// maybe change this to stereo at some point
				grained = GrainBufJ.ar(
					numChannels:1,
					loop: 1,
					trigger:t,
					// dur: overlap / tFreq,
					dur: sc * (overlap + modOverlap.lag(slewing)) / tFreq,
					sndbuf: buf,
					rate: rate - lpf + modRate.lag(slewing),
					pos: readPos + modReadPos.lag(slewing),
					interp: 4,
					// grainAmp: sc,
					pan: 0,
					envbufnum: -1,
					maxGrains: 2048,
				);

				grained = HPF.ar( grained, \hpf.kr(40) );

				signal = Mix([
					LeakDC.ar( grained ) * \wet.kr(0),
					DelayC.ar(
						input,
						0.5,
						(64 + lookahead / SampleRate.ir )
					) * \dry.kr(1),
					//~cleanBus is declared as the sole aux of superclean in the startup.scd
					In.ar(~cleanBus, 2) * cleanAmp
				]) * gain.dbamp;

				signal.tanh

			}).play(~mixerBus, 2, ~grainGroup);

			// Ndef(\granular_comp).edit

		);

		s.sync;

		(
			{
				// caesar needs a bit of patience
				~caesar = CaesarLooper(~mixerBus, ~caesarBus, 16, ~caesarGroup);
				9.wait;
				~caesar.inputLevel_(0);
				1.wait;
				~caesar.dryLevel_(0);
				1.wait;
				~caesar.delay_(16);
				1.wait;
				~caesar.effectLevel_(1);
				1.wait;
				~caesar.masterFeedback_(0);
				5.wait;
				~caesar.clear;
			}.fork;
		);

		s.sync;

		(
			Ndef(\mixer).addSpec(
				\finalAmp, [0.0, 1],
				\caesarAmp, [0.0, 1],
				\reverbAmp, [-1.0, 1.0],
				\damp, [0.0, 1],
			)
		);

		s.sync;

		(

			Ndef(\mixer, {
				arg finalAmp = 0.5, caesarAmp = 0.0, reverbAmp = -1.0;
				var sig, reverb;

				sig = Mix.ar([In.ar(~mixerBus, 2), In.ar(~caesarBus, 2) * caesarAmp/*, In.ar(~cleanBus, 2)*/]);

				// end of chain reverb

				reverb = Mix.ar([
					GVerb.ar(sig[0], 150, 1, \damp.kr(0.5, 0.5), 0.0, 15, 0.0, 0.7, 0.5),
					GVerb.ar(sig[1], 150, 1, \damp.kr(0.5, 0.5), 0.0, 15, 0.0, 0.7, 0.5)
				]);

				reverb = LPF.ar(reverb, 2200);

				/* reverb = Greyhole.ar(sig, \delayTime.kr(2), \damp.kr(0), \size.kr(1),
				\diff.kr(0.707), \feedback.kr(0.9), \modDepth.kr(0.1), \modFreq.kr(0.61)); */

				sig = XFade2.ar(sig, reverb, reverbAmp);

				sig * finalAmp;
			}).play(0, 2, ~mixerGroup);

			// Ndef(\mixer).edit

		);

		/*		(

		Ndef(\writer).play(0, 2, ~writerGroup);

		);*/

		s.sync;
		// just in case, this might get loud
		StageLimiter.activate;

		(
			// midi control things
			m = MKtl('mm',"akai-midimix",multiIndex:0);

			"loading first midimix".postln;
			10.wait;

			//give all the midimix controls names
			MKtl(\mm).addNamed(\knob1, MKtl(\mm).elAt(\kn,0,0));
			MKtl(\mm).addNamed(\knob2, MKtl(\mm).elAt(\kn,0,1));
			MKtl(\mm).addNamed(\knob3, MKtl(\mm).elAt(\kn,0,2));
			MKtl(\mm).addNamed(\knob4, MKtl(\mm).elAt(\kn,0,3));
			MKtl(\mm).addNamed(\knob5, MKtl(\mm).elAt(\kn,0,4));
			MKtl(\mm).addNamed(\knob6, MKtl(\mm).elAt(\kn,0,5));
			MKtl(\mm).addNamed(\knob7, MKtl(\mm).elAt(\kn,0,6));
			MKtl(\mm).addNamed(\knob8, MKtl(\mm).elAt(\kn,0,7));
			MKtl(\mm).addNamed(\knob9, MKtl(\mm).elAt(\kn,1,0));
			MKtl(\mm).addNamed(\knob10, MKtl(\mm).elAt(\kn,1,1));
			MKtl(\mm).addNamed(\knob11, MKtl(\mm).elAt(\kn,1,2));
			MKtl(\mm).addNamed(\knob12, MKtl(\mm).elAt(\kn,1,3));
			MKtl(\mm).addNamed(\knob13, MKtl(\mm).elAt(\kn,1,4));
			MKtl(\mm).addNamed(\knob14, MKtl(\mm).elAt(\kn,1,5));
			MKtl(\mm).addNamed(\knob15, MKtl(\mm).elAt(\kn,1,6));
			MKtl(\mm).addNamed(\knob16, MKtl(\mm).elAt(\kn,1,7));
			MKtl(\mm).addNamed(\knob17, MKtl(\mm).elAt(\kn,2,0));
			MKtl(\mm).addNamed(\knob18, MKtl(\mm).elAt(\kn,2,1));
			MKtl(\mm).addNamed(\knob19, MKtl(\mm).elAt(\kn,2,2));
			MKtl(\mm).addNamed(\knob20, MKtl(\mm).elAt(\kn,2,3));
			MKtl(\mm).addNamed(\knob21, MKtl(\mm).elAt(\kn,2,4));
			MKtl(\mm).addNamed(\knob22, MKtl(\mm).elAt(\kn,2,5));
			MKtl(\mm).addNamed(\knob23, MKtl(\mm).elAt(\kn,2,6));
			MKtl(\mm).addNamed(\knob24, MKtl(\mm).elAt(\kn,2,7));

			MKtl(\mm).addNamed(\button1, MKtl(\mm).elAt(\bt,0,0,0));
			MKtl(\mm).addNamed(\button2, MKtl(\mm).elAt(\bt,0,1,0));
			MKtl(\mm).addNamed(\button3, MKtl(\mm).elAt(\bt,0,2,0));
			MKtl(\mm).addNamed(\button4, MKtl(\mm).elAt(\bt,0,3,0));
			MKtl(\mm).addNamed(\button5, MKtl(\mm).elAt(\bt,0,4,0));
			MKtl(\mm).addNamed(\button6, MKtl(\mm).elAt(\bt,0,5,0));
			MKtl(\mm).addNamed(\button7, MKtl(\mm).elAt(\bt,0,6,0));
			MKtl(\mm).addNamed(\button8, MKtl(\mm).elAt(\bt,0,7,0));
			MKtl(\mm).addNamed(\button9, MKtl(\mm).elAt(\bt,1,0,0));
			MKtl(\mm).addNamed(\button10, MKtl(\mm).elAt(\bt,1,1,0));
			MKtl(\mm).addNamed(\button11, MKtl(\mm).elAt(\bt,1,2,0));
			MKtl(\mm).addNamed(\button12, MKtl(\mm).elAt(\bt,1,3,0));
			MKtl(\mm).addNamed(\button13, MKtl(\mm).elAt(\bt,1,4,0));
			MKtl(\mm).addNamed(\button14, MKtl(\mm).elAt(\bt,1,5,0));
			MKtl(\mm).addNamed(\button15, MKtl(\mm).elAt(\bt,1,6,0));
			MKtl(\mm).addNamed(\button16, MKtl(\mm).elAt(\bt,1,7,0));

			// the hidden buttons
			MKtl(\mm).addNamed(\button17, MKtl(\mm).elAt(\bt,2,0,0));
			MKtl(\mm).addNamed(\button18, MKtl(\mm).elAt(\bt,2,1,0));
			MKtl(\mm).addNamed(\button19, MKtl(\mm).elAt(\bt,2,2,0));
			MKtl(\mm).addNamed(\button20, MKtl(\mm).elAt(\bt,2,3,0));
			MKtl(\mm).addNamed(\button21, MKtl(\mm).elAt(\bt,2,4,0));
			MKtl(\mm).addNamed(\button22, MKtl(\mm).elAt(\bt,2,5,0));
			MKtl(\mm).addNamed(\button23, MKtl(\mm).elAt(\bt,2,6,0));
			MKtl(\mm).addNamed(\button24, MKtl(\mm).elAt(\bt,2,7,0));

			MKtl(\mm).addNamed(\slider1, MKtl(\mm).elAt(\sl,0));
			MKtl(\mm).addNamed(\slider2, MKtl(\mm).elAt(\sl,1));
			MKtl(\mm).addNamed(\slider3, MKtl(\mm).elAt(\sl,2));
			MKtl(\mm).addNamed(\slider4, MKtl(\mm).elAt(\sl,3));
			MKtl(\mm).addNamed(\slider5, MKtl(\mm).elAt(\sl,4));
			MKtl(\mm).addNamed(\slider6, MKtl(\mm).elAt(\sl,5));
			MKtl(\mm).addNamed(\slider7, MKtl(\mm).elAt(\sl,6));
			MKtl(\mm).addNamed(\slider8, MKtl(\mm).elAt(\sl,7));
			MKtl(\mm).addNamed(\slider9, MKtl(\mm).elAt(\sl,8));

			MKtl(\mm).addNamed(\bankleft, MKtl(\mm).elAt(\bankLeft,0));
			MKtl(\mm).addNamed(\bankright, MKtl(\mm).elAt(\bankRight,0));

			//second midimix!

			l = MKtl('sq',"akai-midimix",multiIndex:1);

			"loading second midimix".postln;
			10.wait;

			MKtl(\sq).addNamed(\knob1, MKtl(\sq).elAt(\kn,0,0));
			MKtl(\sq).addNamed(\knob2, MKtl(\sq).elAt(\kn,0,1));
			MKtl(\sq).addNamed(\knob3, MKtl(\sq).elAt(\kn,0,2));
			MKtl(\sq).addNamed(\knob4, MKtl(\sq).elAt(\kn,0,3));
			MKtl(\sq).addNamed(\knob5, MKtl(\sq).elAt(\kn,0,4));
			MKtl(\sq).addNamed(\knob6, MKtl(\sq).elAt(\kn,0,5));
			MKtl(\sq).addNamed(\knob7, MKtl(\sq).elAt(\kn,0,6));
			MKtl(\sq).addNamed(\knob8, MKtl(\sq).elAt(\kn,0,7));
			MKtl(\sq).addNamed(\knob9, MKtl(\sq).elAt(\kn,1,0));
			MKtl(\sq).addNamed(\knob10, MKtl(\sq).elAt(\kn,1,1));
			MKtl(\sq).addNamed(\knob11, MKtl(\sq).elAt(\kn,1,2));
			MKtl(\sq).addNamed(\knob12, MKtl(\sq).elAt(\kn,1,3));
			MKtl(\sq).addNamed(\knob13, MKtl(\sq).elAt(\kn,1,4));
			MKtl(\sq).addNamed(\knob14, MKtl(\sq).elAt(\kn,1,5));
			MKtl(\sq).addNamed(\knob15, MKtl(\sq).elAt(\kn,1,6));
			MKtl(\sq).addNamed(\knob16, MKtl(\sq).elAt(\kn,1,7));
			MKtl(\sq).addNamed(\knob17, MKtl(\sq).elAt(\kn,2,0));
			MKtl(\sq).addNamed(\knob18, MKtl(\sq).elAt(\kn,2,1));
			MKtl(\sq).addNamed(\knob19, MKtl(\sq).elAt(\kn,2,2));
			MKtl(\sq).addNamed(\knob20, MKtl(\sq).elAt(\kn,2,3));
			MKtl(\sq).addNamed(\knob21, MKtl(\sq).elAt(\kn,2,4));
			MKtl(\sq).addNamed(\knob22, MKtl(\sq).elAt(\kn,2,5));
			MKtl(\sq).addNamed(\knob23, MKtl(\sq).elAt(\kn,2,6));
			MKtl(\sq).addNamed(\knob24, MKtl(\sq).elAt(\kn,2,7));

			MKtl(\sq).addNamed(\button1, MKtl(\sq).elAt(\bt,0,0,0));
			MKtl(\sq).addNamed(\button2, MKtl(\sq).elAt(\bt,0,1,0));
			MKtl(\sq).addNamed(\button3, MKtl(\sq).elAt(\bt,0,2,0));
			MKtl(\sq).addNamed(\button4, MKtl(\sq).elAt(\bt,0,3,0));
			MKtl(\sq).addNamed(\button5, MKtl(\sq).elAt(\bt,0,4,0));
			MKtl(\sq).addNamed(\button6, MKtl(\sq).elAt(\bt,0,5,0));
			MKtl(\sq).addNamed(\button7, MKtl(\sq).elAt(\bt,0,6,0));
			MKtl(\sq).addNamed(\button8, MKtl(\sq).elAt(\bt,0,7,0));
			MKtl(\sq).addNamed(\button9, MKtl(\sq).elAt(\bt,1,0,0));
			MKtl(\sq).addNamed(\button10, MKtl(\sq).elAt(\bt,1,1,0));
			MKtl(\sq).addNamed(\button11, MKtl(\sq).elAt(\bt,1,2,0));
			MKtl(\sq).addNamed(\button12, MKtl(\sq).elAt(\bt,1,3,0));
			MKtl(\sq).addNamed(\button13, MKtl(\sq).elAt(\bt,1,4,0));
			MKtl(\sq).addNamed(\button14, MKtl(\sq).elAt(\bt,1,5,0));
			MKtl(\sq).addNamed(\button15, MKtl(\sq).elAt(\bt,1,6,0));
			MKtl(\sq).addNamed(\button16, MKtl(\sq).elAt(\bt,1,7,0));

			// the hidden buttons
			MKtl(\sq).addNamed(\button17, MKtl(\sq).elAt(\bt,2,0,0));
			MKtl(\sq).addNamed(\button18, MKtl(\sq).elAt(\bt,2,1,0));
			MKtl(\sq).addNamed(\button19, MKtl(\sq).elAt(\bt,2,2,0));
			MKtl(\sq).addNamed(\button20, MKtl(\sq).elAt(\bt,2,3,0));
			MKtl(\sq).addNamed(\button21, MKtl(\sq).elAt(\bt,2,4,0));
			MKtl(\sq).addNamed(\button22, MKtl(\sq).elAt(\bt,2,5,0));
			MKtl(\sq).addNamed(\button23, MKtl(\sq).elAt(\bt,2,6,0));
			MKtl(\sq).addNamed(\button24, MKtl(\sq).elAt(\bt,2,7,0));

			MKtl(\sq).addNamed(\slider1, MKtl(\sq).elAt(\sl,0));
			MKtl(\sq).addNamed(\slider2, MKtl(\sq).elAt(\sl,1));
			MKtl(\sq).addNamed(\slider3, MKtl(\sq).elAt(\sl,2));
			MKtl(\sq).addNamed(\slider4, MKtl(\sq).elAt(\sl,3));
			MKtl(\sq).addNamed(\slider5, MKtl(\sq).elAt(\sl,4));
			MKtl(\sq).addNamed(\slider6, MKtl(\sq).elAt(\sl,5));
			MKtl(\sq).addNamed(\slider7, MKtl(\sq).elAt(\sl,6));
			MKtl(\sq).addNamed(\slider8, MKtl(\sq).elAt(\sl,7));
			MKtl(\sq).addNamed(\slider9, MKtl(\sq).elAt(\sl,8));

			MKtl(\sq).addNamed(\bankleft, MKtl(\sq).elAt(\bankLeft,0));
			MKtl(\sq).addNamed(\bankright, MKtl(\sq).elAt(\bankRight,0));

			/* this is a 5-bit binary "display" to have some feedback
			when scrolling through the buffers on the disk */
			/*~showCurrentLoop = {
			var binArray;
			binArray = ~currentLoop.asBinaryDigits(6).reverse;
			MKtl(\mm).elAt(\bt,1,2,0).value_(binArray[0].linlin(0,1,0,127));
			MKtl(\mm).elAt(\bt,1,3,0).value_(binArray[1].linlin(0,1,0,127));
			MKtl(\mm).elAt(\bt,1,4,0).value_(binArray[2].linlin(0,1,0,127));
			MKtl(\mm).elAt(\bt,1,5,0).value_(binArray[3].linlin(0,1,0,127));
			MKtl(\mm).elAt(\bt,1,6,0).value_(binArray[4].linlin(0,1,0,127));
			};

			~showCleanLoop = {
			var binArray;
			binArray = ~cleanLoop.asBinaryDigits(6).reverse;
			MKtl(\sq).elAt(\bt,1,2,0).value_(binArray[0].linlin(0,1,0,127));
			MKtl(\sq).elAt(\bt,1,3,0).value_(binArray[1].linlin(0,1,0,127));
			MKtl(\sq).elAt(\bt,1,4,0).value_(binArray[2].linlin(0,1,0,127));
			MKtl(\sq).elAt(\bt,1,5,0).value_(binArray[3].linlin(0,1,0,127));
			MKtl(\sq).elAt(\bt,1,6,0).value_(binArray[4].linlin(0,1,0,127));
			};*/

			//workaround time:
			//because of modality bugs i can only show led lights on both
			//devices so i have to choose loops with 2x 4bin arrays showing
			//on both midimixes:

			~showCurrentLoop = {
				var binArray;
				binArray = ~currentLoop.asBinaryDigits(4).reverse;
				MKtl(\mm).elAt(\bt,1,0,0).value_(binArray[0].linlin(0,1,0,127));
				MKtl(\mm).elAt(\bt,1,1,0).value_(binArray[1].linlin(0,1,0,127));
				MKtl(\mm).elAt(\bt,1,2,0).value_(binArray[2].linlin(0,1,0,127));
				MKtl(\mm).elAt(\bt,1,3,0).value_(binArray[3].linlin(0,1,0,127));
			};

			~showCleanLoop = {
				var binArray;
				binArray = ~cleanLoop.asBinaryDigits(4).reverse;
				MKtl(\sq).elAt(\bt,1,4,0).value_(binArray[0].linlin(0,1,0,127));
				MKtl(\sq).elAt(\bt,1,5,0).value_(binArray[1].linlin(0,1,0,127));
				MKtl(\sq).elAt(\bt,1,6,0).value_(binArray[2].linlin(0,1,0,127));
				MKtl(\sq).elAt(\bt,1,7,0).value_(binArray[3].linlin(0,1,0,127));
			};

			// define what the actions actually do
			~controls_mm = (
				actions: (
					/////////////////////////////////
					//master midimix controls
					/////////////////////////////////

					//buttons
					selectBefore: {
						MKtl(\mm).elAt(\bt,1,0,0).value_(127);
						~currentLoop = ~currentLoop-1%~numLoops;

						Ndef(\tape).set(\bufn, ~arrayOfBuffers[~currentLoop]);
						MKtl(\mm).elAt(\bt,1,0,0).value_(0);
						~showCurrentLoop.value;
						~showCleanLoop.value;
					},
					selectNext: {
						MKtl(\mm).elAt(\bt,1,1,0).value_(127);
						~currentLoop = ~currentLoop+1%~numLoops;

						Ndef(\tape).set(\bufn,~arrayOfBuffers[~currentLoop]);
						MKtl(\mm).elAt(\bt,1,1,0).value_(0);
						~showCurrentLoop.value;
						~showCleanLoop.value;
					},
					tapLength: { ~caesar.tapLength;},
					record: { if (~caesar.inputLevel == 1,
						{ MKtl(\mm).elAt(\bt,0,5,0).value_(0);
							~caesar.inputLevel_(0);
						}, { MKtl(\mm).elAt(\bt,0,5,0).value_(127);
							~caesar.inputLevel_(1);
					});},
					reverse: { ~caesar.reverse;},
					freeze: { if (~caesar.isFrozen,
						{ MKtl(\mm).elAt(\bt,0,7,0).value_(0);
							~caesar.freeze;
						}, { MKtl(\mm).elAt(\bt,0,7,0).value_(127);
							~caesar.freeze;
					});},
					// beware: adding readheads may make a feedback mess, use with caution
					// addReadHead: { if(~caesar.reads[7]==nil,{~caesar.addRead(~nextReadDiv,~nextReadLevel,rrand(-0.05,0.05));},{"too many read heads".postln;});},
					// removeReadHead: { if(~caesar.reads[1]==nil,{"don't want to remove the main read head".postln;},{~caesar.removeRead;});},

					// tapestuff
					setTapeSpeed: { arg element; if(~playing,{
						Ndef(\tape).set(\rate, element.value.linexp(0, 1, 0.125, 8));
					},{})},
					setTapeStart: { arg element; Ndef(\tape).set(\start, element.value); },
					setTapeEnd: { arg element; Ndef(\tape).set(\end, element.value); },
					setTapeLowpass: { arg element;
						Ndef(\tape).set(\lpf, element.value.linlin(0, 1, 20, 22050));
						~cleanLo = element.value.linlin(0, 1, 36, 20000);
					},
					setTapeHighpass: { arg element;
						Ndef(\tape).set(\hpf, element.value.linlin(0, 1, 10, 20050));
						~cleanHi = element.value.linlin(0, 1, 16, 18050);
					},
					setDrop: { arg element; Ndef(\granular_comp).set(\drop, element.value.linlin(0, 1, 0, 90)); },

					// analysis & grancomp
					setAnalysisHighpass: { arg element; Ndef(\analysis).set(\hpf, element.value.linexp(0, 1, 10, 1000)); },
					setAnalysisAttack: { arg element; Ndef(\analysis).set(\attack, element.value.linlin(0, 1, 0.001, 0.2)); },
					setAnalysisRelease: { arg element; Ndef(\analysis).set(\release, element.value.linlin(0, 1, 0.001, 0.3)); },
					setAnalysisThreshold: { arg element; Ndef(\analysis).set(\threshold, element.value.linlin(0, 1, -100.0, -30.0)); },
					// setAnalysisKnee: { arg element; Ndef(\analysis).set(\knee, element.value.linlin(0, 1, 0.9, 1.1)); },
					setMasterSlew: { arg element; ~masterSlew = element.value.linlin(0, 1, 0, 20); },

					setGranLookahead: { arg element; Ndef(\granular_comp).set(\lookahead, element.value.linlin(0, 1, 0, 4100)); },
					setGranLowpass: { arg element; Ndef(\granular_comp).set(\lpf, element.value.linlin(0, 1, 0.0, 0.2)); },
					setGranHighpass: { arg element; Ndef(\granular_comp).set(\hpf, element.value.linexp(0, 1, 10, 22050)); },
					setGranGain: { arg element; Ndef(\granular_comp).set(\gain, element.value.linlin(0, 1, 0.0, 40.0)); },
					setGranRate: { arg element; Ndef(\granular_comp).set(\rate, element.value); },
					setGranTFreq: { arg element; Ndef(\granular_comp).set(\tFreq, element.value.linexp(0, 1, 1, 22050)); },
					setGranOverlap: { arg element; Ndef(\granular_comp).set(\overlap, element.value.linexp(0, 1, 0.1, 1024.0)); },
					setAnalysisRatio: { arg element; Ndef(\analysis).set(\ratio, element.value.linlin(0, 1, 1.0, 4.0)); },

					// caesarstuff
					setCaesarPitch: { arg element; ~caesar.pitch_(element.value.linlin(0,1,-4,4));},
					setCaesarFeedback: { arg element; ~caesar.masterFeedback_(element.value);},

					// chord action
					setShiftDistance: { arg element; Ndef(\tape).set(\shiftdistance, element.value.linlin(0, 1, -1, 1)); },
					setPitch2Amp: { arg element; Ndef(\tape).set(\pitch2amp, element.value); },
					setPitch3Amp: { arg element; Ndef(\tape).set(\pitch3amp, element.value); },

					// reverb
					// setReverbDamping: { arg element; Ndef(\reverb).set(\damp, el.value); },
					setReverbLevel: { arg element; Ndef(\mixer).set(\reverbAmp, element.value.linlin(0, 1, -1.0, 1.0)); },

					// vols
					setInAmp: { arg element; Ndef(\granular_comp).set(\inAmp, element.value); },
					setInAmpBypass: { arg element; Ndef(\input).set(\amp, element.value.linlin(0, 1, 0, 0.8)); },
					setTapeAmp: { arg element; Ndef(\tape).set(\tapeAmp, element.value); },
					setDryAmp: { arg element; Ndef(\granular_comp).set(\dry, element.value); },
					setGrainAmp: { arg element; Ndef(\granular_comp).set(\wet, element.value); },
					setCaesarAmp: { arg element; Ndef(\mixer).set(\caesarAmp, element.value); },
					setFinalAmp: { arg element; Ndef(\mixer).set(\finalAmp, element.value); },

					playTape: { if (~playing,{
						~playing = false;
						MKtl(\mm).elAt(\bt,0,1,0).value_(0);
						Ndef(\tape).set(\rate, 0);
					},{
						~playing = true;
						MKtl(\mm).elAt(\bt,0,1,0).value_(127);
						m.elementAt(\knob1).doAction;
					})},

					bypass: { if (~bypass,{
						Ndef(\input, {
							var amp, sig;
							amp = \amp.kr(0.8, 0.01);
							// sig = SoundIn.ar(0) ! 2;
							sig = SoundIn.ar([0, 1]);
							sig * amp;
						}).play(~inputBus, 2, ~sourceGroup);
						MKtl(\mm).elAt(\bt,0,0,0).value_(0);
						MKtl(\mm).elAt(\slider1).postln.action = ~controls.actions[\setInAmp.postln].postln;
						~bypass = false;
					},{
						Ndef(\input, {
							var amp, sig;
							amp = \amp.kr(0.8, 0.01);
							// sig = SoundIn.ar(0) ! 2;
							sig = SoundIn.ar([0, 1]);
							sig * amp;
						}).play(0, 2, ~sourceGroup);
						MKtl(\mm).elAt(\bt,0,0,0).value_(127);
						MKtl(\mm).elAt(\slider1).postln.action = ~controls.actions[\setInAmpBypass.postln].postln;
						~bypass = true;
					}
					);},
					playClean: {
						if(~cleanPlays, {
							Pdef(0).stop;
							~cleanPlays = false;
							MKtl(\mm).elAt(\bt,0,2,0).value_(0);
						},{
							Pdef(0).play;
							~cleanPlays = true;
							MKtl(\mm).elAt(\bt,0,2,0).value_(127);
					});},
					randomizeClean: { arg element;
						~seed = 2147483647.rand;
						// ~t_cleanGate = true;
					},
					setCleanSpeed: { arg element; ~speedDivider = element.value.linlin(0,1,1.0,5.0); },

					setCleanMod: { arg element; ~cleanMod = element.value.linlin(0, 1, -1, 1); },

					toggleModTapeRate: {
						if(~modTapeRate, {
							~modTapeRate = false;
							MKtl(\mm).elAt(\bt,2,0,0).value_(0);
						},{
							~modTapeRate = true;
							MKtl(\mm).elAt(\bt,2,0,0).value_(127);
					});},

					toggleModTapePos: {
						if(~modTapePos, {
							~modTapePos = false;
							MKtl(\mm).elAt(\bt,2,1,0).value_(0);
						},{
							~modTapePos = true;
							MKtl(\mm).elAt(\bt,2,1,0).value_(127);
					});},
					toggleModLoopPitch: {
						if(~modLoopPitch, {
							~modLoopPitch = false;
							MKtl(\mm).elAt(\bt,2,2,0).value_(0);
						},{
							~modLoopPitch = true;
							MKtl(\mm).elAt(\bt,2,2,0).value_(127);
					});},
					toggleModLoopFeedback: {
						if(~modLoopFeedback, {
							~modLoopFeedback = false;
							MKtl(\mm).elAt(\bt,2,3,0).value_(0);
						},{
							~modLoopFeedback = true;
							MKtl(\mm).elAt(\bt,2,3,0).value_(127);
					});},
					toggleModGrainRate: {
						if(~modGrainRate, {
							~modGrainRate = false;
							MKtl(\mm).elAt(\bt,2,4,0).value_(0);
						},{
							~modGrainRate = true;
							MKtl(\mm).elAt(\bt,2,4,0).value_(127);
					});},
					toggleModTFreq: {
						if(~modGrainTFreq, {
							~modGrainTFreq = false;
							MKtl(\mm).elAt(\bt,2,5,0).value_(0);
						},{
							~modGrainTFreq = true;
							MKtl(\mm).elAt(\bt,2,5,0).value_(127);
					});},
					toggleModOverlap: {
						if(~modGrainOverlap, {
							~modGrainOverlap = false;
							MKtl(\mm).elAt(\bt,2,6,0).value_(0);
						},{
							~modGrainOverlap = true;
							MKtl(\mm).elAt(\bt,2,6,0).value_(127);
					});},
					toggleModGrainPos: {
						if(~modGrainPos, {
							~modGrainPos = false;
							MKtl(\mm).elAt(\bt,2,7,0).value_(0);
						},{
							~modGrainPos = true;
							MKtl(\mm).elAt(\bt,2,7,0).value_(127);
					});},
			));

			/////////////////////////////////
			// sequencer midimix actions
			/////////////////////////////////
			~controls_sq = (
				actions: (
					selectCleanBefore: {
						MKtl(\sq).elAt(\bt,1,0,0).value_(127);
						~cleanLoop = ~cleanLoop-1%~numLoops;

						MKtl(\sq).elAt(\bt,1,0,0).value_(0);
						~showCurrentLoop.value;
						~showCleanLoop.value;
					},
					selectCleanNext: {
						MKtl(\sq).elAt(\bt,1,1,0).value_(127);
						~cleanLoop = ~cleanLoop+1%~numLoops;

						MKtl(\sq).elAt(\bt,1,1,0).value_(0);
						~showCurrentLoop.value;
						~showCleanLoop.value;
					},

					step1Pitch: { arg element; ~degrees[0] = element.value.linlin(0,1,-2.5,2.5); },
					step2Pitch: { arg element; ~degrees[1] = element.value.linlin(0,1,-2.5,2.5); },
					step3Pitch: { arg element; ~degrees[2] = element.value.linlin(0,1,-2.5,2.5); },
					step4Pitch: { arg element; ~degrees[3] = element.value.linlin(0,1,-2.5,2.5); },
					step5Pitch: { arg element; ~degrees[4] = element.value.linlin(0,1,-2.5,2.5); },
					step6Pitch: { arg element; ~degrees[5] = element.value.linlin(0,1,-2.5,2.5); },
					step7Pitch: { arg element; ~degrees[6] = element.value.linlin(0,1,-2.5,2.5); },
					step8Pitch: { arg element; ~degrees[7] = element.value.linlin(0,1,-2.5,2.5); },

					step1Dur: { arg element; ~durs[0] = element.value.linlin(0,1,0.01,2); },
					step2Dur: { arg element; ~durs[1] = element.value.linlin(0,1,0.01,2); },
					step3Dur: { arg element; ~durs[2] = element.value.linlin(0,1,0.01,2); },
					step4Dur: { arg element; ~durs[3] = element.value.linlin(0,1,0.01,2); },
					step5Dur: { arg element; ~durs[4] = element.value.linlin(0,1,0.01,2); },
					step6Dur: { arg element; ~durs[5] = element.value.linlin(0,1,0.01,2); },
					step7Dur: { arg element; ~durs[6] = element.value.linlin(0,1,0.01,2); },
					step8Dur: { arg element; ~durs[7] = element.value.linlin(0,1,0.01,2); },

					step1Amp: { arg element; ~amps[0] = element.value; },
					step2Amp: { arg element; ~amps[1] = element.value; },
					step3Amp: { arg element; ~amps[2] = element.value; },
					step4Amp: { arg element; ~amps[3] = element.value; },
					step5Amp: { arg element; ~amps[4] = element.value; },
					step6Amp: { arg element; ~amps[5] = element.value; },
					step7Amp: { arg element; ~amps[6] = element.value; },
					step8Amp: { arg element; ~amps[7] = element.value; },

					setLegato: { arg element; ~legato = element.value.linlin(0,1,1,50); },
					setTraverse: { arg element; ~traverse = element.value.linlin(0,1,0.1,100); },
					setAttack: { arg element; ~atk = element.value.linlin(0,1,0.01,1.5); },
					setRelease: { arg element; ~rel = element.value.linlin(0,1,0.1,3.0); },

					setInfluence1: { arg element; ~influence[0] = element.value; },
					setInfluence2: { arg element; ~influence[1] = element.value; },
					setInfluence3: { arg element; ~influence[2] = element.value; },
					setInfluence4: { arg element; ~influence[3] = element.value; },

					setCleanAmp:  { arg element; Ndef(\granular_comp).set(\cleanAmp, element.value); },
			));

			// sort out which control gets which action
			"putting mm controls".postln;
			~controls_mm.put(
				\mm, (
					\ctlMap1: (
						\button1: \bypass,
						\button2: \playTape,

						\button3: \playClean,
						\button4: \randomizeClean,

						\button5: \tapLength,
						\button6: \record,
						\button7: \reverse,
						\button8: \freeze,
						\button9: \selectBefore,
						\button10: \selectNext,

						// mod targets:
						\button17: \toggleModTapeRate,
						\button18: \toggleModTapePos,
						\button19: \toggleModLoopPitch,
						\button20: \toggleModLoopFeedback,
						\button21: \toggleModGrainRate,
						\button22: \toggleModTFreq,
						\button23: \toggleModOverlap,
						\button24: \toggleModGrainPos,

						// tapestuff
						\knob1: \setTapeSpeed,
						\knob2: \setTapeStart,
						\knob3: \setTapeEnd,

						// analysis & granular
						\knob4: \setAnalysisHighpass,
						\knob5: \setAnalysisAttack,
						\knob6: \setAnalysisRelease,
						\knob7: \setAnalysisThreshold,
						// \knob8: \setAnalysisKnee,
						\knob8: \setMasterSlew,
						\knob9: \setGranLookahead,
						\knob10: \setGranLowpass,
						\knob11: \setGranHighpass,
						\knob12: \setGranGain,
						\knob13: \setGranRate,
						\knob14: \setGranTFreq,
						\knob15: \setGranOverlap,
						\knob16: \setAnalysisRatio,

						// again some tapestuff
						\knob17: \setTapeLowpass,
						\knob18: \setTapeHighpass,

						// caesarstuff
						\knob19: \setCaesarPitch,
						\knob20: \setCaesarFeedback,

						// the waveloss
						\knob21: \setDrop,

						// chordstuff
						\knob22: \setShiftDistance,

						//reverb
						// \knob23: \setReverbDamping,
						// \knob24: \setReverbLevel,
						\knob23: \setCleanSpeed,
						\knob24: \setCleanMod,

						// volumes
						\slider1: \setInAmp,
						\slider2: \setTapeAmp,
						\slider3: \setDryAmp,
						\slider4: \setGrainAmp,
						\slider5: \setCaesarAmp,
						\slider6: \setPitch2Amp,
						\slider7: \setPitch3Amp,
						\slider8: \setReverbLevel,
						\slider9: \setFinalAmp
					)
				),
			);

			"putting sq controls".postln;
			~controls_sq.put(
				\sq, (
					\ctlMap2: (

						\button9: \selectCleanBefore,
						\button10: \selectCleanNext,

						//degrees
						\knob1: \step1Pitch,
						\knob2: \step2Pitch,
						\knob3: \step3Pitch,
						\knob4: \step4Pitch,
						\knob5: \step5Pitch,
						\knob6: \step6Pitch,
						\knob7: \step7Pitch,
						\knob8: \step8Pitch,
						//durs
						\knob9: \step1Dur,
						\knob10: \step2Dur,
						\knob11: \step3Dur,
						\knob12: \step4Dur,
						\knob13: \step5Dur,
						\knob14: \step6Dur,
						\knob15: \step7Dur,
						\knob16: \step8Dur,
						//influence
						\knob17: \setInfluence1,
						\knob18: \setInfluence2,
						\knob19: \setInfluence3,
						\knob20: \setInfluence4,

						//parameters
						\knob21: \setLegato,
						\knob22: \setTraverse,
						\knob23: \setAttack,
						\knob24: \setRelease,

						//amps
						\slider1: \step1Amp,
						\slider2: \step2Amp,
						\slider3: \step3Amp,
						\slider4: \step4Amp,
						\slider5: \step5Amp,
						\slider6: \step6Amp,
						\slider7: \step7Amp,
						\slider8: \step8Amp,

						\slider9: \setCleanAmp,

					)
				),
			);

			~controls_mm.mm.ctlMap1.keysValuesDo { arg elName, actName;
				MKtl(\mm).elAt(elName).postln.action = ~controls_mm.actions[actName.postln].postln;
			};

			~controls_sq.sq.ctlMap2.keysValuesDo { arg elName, actName;
				MKtl(\sq).elAt(elName).postln.action = ~controls_sq.actions[actName.postln].postln;
			};
			// m.gui;
		);

		(
			// reset lights
			3.do({arg i;
				8.do({arg j;
					MKtl(\mm).elAt(\bt,i,j,0).value_(0);
					MKtl(\sq).elAt(\bt,i,j,0).value_(0);
				});
			});

			// change values to corresponding knob and sliders
			/*24.do({
			arg i;
			m.elementAt((\knob ++ (i+1)).asSymbol).doAction;
			});

			9.do({
			arg i;
			m.elementAt((\slider ++ (i+1)).asSymbol).doAction;
			});*/

			// tape is playing by default
			MKtl(\mm).elAt(\bt,0,1,0).value_(127);
		);

		Pdef(0,
			Pbind(*[
				type: \cln,
				snd: \fields,
				step: Pseq((0..7),inf),
				num: Pfunc{~cleanLoop},

				// timeframe: Pdup(inf, Pwhite(1, 4)),
				seed: Pfunc{~seed},
				cleanMod: Pfunc{~cleanMod}, // defines how much is applied to outer stuff

				//calculate random, but really repeating movements!
				mod1: Pn(Plazy{
					var length = 13.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0,5,length) * Pkey(\cleanMod) * Pfunc{ arg event;~amps[event.step]});
				})/* + (Pseg([0, 1, 0], Pkey(\dur) * Pkey(\timeframe), \sin, inf) * Pkey(\cleanMod))*/,
				mod2: Pn(Plazy{
					var length = 11.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0,100,length) * Pkey(\cleanMod) * Pfunc{ arg event;~amps[event.step]});
				}),
				mod3: Pn(Plazy{
					var length = 15.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0.1,0.5,length) * Pkey(\cleanMod) * Pfunc{ arg event;~amps[event.step]});
				}),
				mod4: Pn(Plazy{
					var length = 9.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0.01,0.3,length) * Pkey(\cleanMod) * Pfunc{ arg event;~amps[event.step]});
				}),
				mod5: Pn(Plazy{
					var length = 12.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0.1,0.5,length) * Pkey(\cleanMod) * Pfunc{ arg event;~amps[event.step]});
				}),
				mod6: Pn(Plazy{
					var length = 13.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0,2000,length) * Pkey(\cleanMod) * Pfunc{ arg event;~amps[event.step]});
				}),
				mod7: Pn(Plazy{
					var length = 11.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0,150,length) * Pkey(\cleanMod) * Pfunc{ arg event;~amps[event.step]});
				}),
				mod8: Pn(Plazy{
					var length = 14.rand + 3;
					Pseed(Pkey(\seed), Pwhite(0,100,length) * Pkey(\cleanMod) * Pfunc{ arg event;~amps[event.step]});
				}),
				// TODO add controllable lag to all places
				fmod1: Pfunc{ arg event; if(~modTapeRate,{
					Ndef(\tape).set(\rate, MKtl(\mm).elAt(\kn,0,0).value.linexp(0, 1, 0.125, 8) + event.mod1);
					"1 change to"++event.mod1.value.postln;
				},{
					"1 no change".postln;
				}); },
				fmod2: Pfunc{ arg event; if(~modTapePos,{
					Ndef(\tape).set(\start, (MKtl(\mm).elAt(\kn,0,1).value + event.mod2).abs % 1);
					"2 change to"++event.mod2.value.postln;
				},{
					"2 no change".postln;
				}); },
				fmod3: Pfunc{ arg event; if(~modLoopPitch,{
					~caesar.pitch_(MKtl(\mm).elAt(\kn,2,2).value.linlin(0,1,-4,4) + event.mod3);
					"3 change to"++event.mod3.value.postln;
				},{
					"3 no change".postln;
				}); },
				fmod4: Pfunc{ arg event; if(~modLoopFeedback,{
					~caesar.masterFeedback_(MKtl(\mm).elAt(\kn,2,3).value + event.mod4);
					"4 change to"++event.mod4.value.postln;
				},{
					"4 no change".postln;
				}); },

				//i guess it's possible to break this with some values, need to
				//investigate and catch all wrongdoings

				fmod5: Pfunc{ arg event; if(~modGrainRate,{
					Ndef(\granular_comp).set(\modRate, event.mod5);
					"5 change to"++event.mod5.value.postln;
				},{
					"5 no change".postln;
				}); },
				fmod6: Pfunc{ arg event; if(~modGrainTFreq,{
					Ndef(\granular_comp).set(\modTFreq, event.mod6);
					"6 change to"++event.mod6.value.postln;
				},{
					"6 no change".postln;
				}); },
				fmod7: Pfunc{ arg event; if(~modGrainOverlap,{
					Ndef(\granular_comp).set(\modOverlap, event.mod7);
					"7 change to"++event.mod7.value.postln;
				},{
					"7 no change".postln;
				}); },
				fmod8: Pfunc{ arg event; if(~modGrainPos,{
					Ndef(\granular_comp).set(\modReadPos, event.mod8);
					"8 change to"++event.mod8.value.postln;
				},{
					"8 no change".postln;
				}); },

				influence1: Pfunc{~influence[0]},
				influence2: Pfunc{~influence[1]},
				influence3: Pfunc{~influence[2]},
				influence4: Pfunc{~influence[3]},

				dur: Pfunc{ arg event;~durs[event.step] / ~speedDivider; },
				// dur: 1,
				traverse: Pfunc{~traverse},
				bgn: (Pseg([0,0.8], Pkey(\traverse), \lin, inf) + ((Pkey(\mod3) * Pkey(\influence2)))) % 0.9,
				spd: Pfunc{ arg event;~degrees[event.step]} + ((Pkey(\mod1) * Pkey(\influence1))),
				// spd: Pfunc{ arg event;~degrees[event.step]},
				// spd: 1,
				// degree: Pfunc{ arg event;~degrees[event.step]},
				// amp: Pfunc{ arg event; ~amps[event.step]} + ((Pkey(\mod3) * Pkey(\influence2))),
				amp: Pfunc{ arg event; ~amps[event.step]},
				// amp: Pfunc{ arg event;~amps[event.step] * ~cleanAmp;},
				legato: Pfunc{~legato} + ((Pkey(\mod8) * (Pkey(\influence4) / 10))),
				// legato: Pfunc{~legato},
				atk: Pfunc{~atk} + (Pkey(\mod4) * Pkey(\influence3)),
				// atk: Pfunc{~atk},
				hld: Pfunc{~legato},
				rel: Pfunc{~rel} ,
				// crv: 4,
				hpf: Pfunc{~cleanHi;},
				lpf: Pfunc{~cleanLo;},

				tnh: Pfunc{~tnh},
				tng: 1.1,

				// out: ~cleanBus,
				// util: Pfunc{ arg event; event.step.postln;}
			]),

		);
	);

);

}

);
